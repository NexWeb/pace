// Code generated by oto; DO NOT EDIT.

package pace

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"strings"
	"time"

	"github.com/pkg/errors"
)

// Client is used to access Pace services.
type Client struct {
	// RemoteHost is the URL of the remote server that this Client should
	// access. Default: https://pace.dev
	RemoteHost string
	// HTTPClient is the http.Client to use when making HTTP requests.
	HTTPClient *http.Client
	// Debug writes a line of debug log output.
	Debug func(s string)
	// apiKey is the API key to use when interacting with the server.
	apiKey string
}

// New makes a new Client.
func New(apiKey string) *Client {
	c := &Client{
		RemoteHost: "https://pace.dev",
		apiKey:     apiKey,
		Debug:      func(s string) {},
		HTTPClient: &http.Client{Timeout: 10 * time.Second},
	}
	return c
}

type CardsService struct {
	client *Client
}

// NewCardsService makes a new client for accessing CardsService services.
func NewCardsService(client *Client) *CardsService {
	return &CardsService{
		client: client,
	}
}

func (s *CardsService) CreateCard(ctx context.Context, r CreateCardRequest) (*CreateCardResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.CreateCard: marshal CreateCardRequest")
	}
	url := s.client.RemoteHost + "/oto/CardsService.CreateCard"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.CreateCard: NewRequest")
	}
	req.Header.Set("X-API-KEY", s.client.apiKey)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.CreateCard")
	}
	defer resp.Body.Close()
	var response CreateCardResponse
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "CardsService.CreateCard: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.CreateCard: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("CardsService.CreateCard: %v %s: %v", resp.StatusCode, http.StatusText(resp.StatusCode), string(respBodyBytes))
		}
		return nil, err
	}
	return &response, nil
}

func (s *CardsService) GetCard(ctx context.Context, r GetCardRequest) (*GetCardResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.GetCard: marshal GetCardRequest")
	}
	url := s.client.RemoteHost + "/oto/CardsService.GetCard"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.GetCard: NewRequest")
	}
	req.Header.Set("X-API-KEY", s.client.apiKey)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.GetCard")
	}
	defer resp.Body.Close()
	var response GetCardResponse
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "CardsService.GetCard: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.GetCard: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("CardsService.GetCard: %v %s: %v", resp.StatusCode, http.StatusText(resp.StatusCode), string(respBodyBytes))
		}
		return nil, err
	}
	return &response, nil
}

type CommentsService struct {
	client *Client
}

// NewCommentsService makes a new client for accessing CommentsService services.
func NewCommentsService(client *Client) *CommentsService {
	return &CommentsService{
		client: client,
	}
}

func (s *CommentsService) AddComment(ctx context.Context, r AddCommentRequest) (*AddCommentResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "CommentsService.AddComment: marshal AddCommentRequest")
	}
	url := s.client.RemoteHost + "/oto/CommentsService.AddComment"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "CommentsService.AddComment: NewRequest")
	}
	req.Header.Set("X-API-KEY", s.client.apiKey)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "CommentsService.AddComment")
	}
	defer resp.Body.Close()
	var response AddCommentResponse
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "CommentsService.AddComment: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "CommentsService.AddComment: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("CommentsService.AddComment: %v %s: %v", resp.StatusCode, http.StatusText(resp.StatusCode), string(respBodyBytes))
		}
		return nil, err
	}
	return &response, nil
}

type AddCommentRequest struct {
	OrgID string `json:"OrgID"`

	TargetKind string `json:"TargetKind"`

	TargetID string `json:"TargetID"`

	Body string `json:"Body"`
}

type Person struct {
	ID string `json:"ID"`

	Username string `json:"Username"`

	Name string `json:"Name"`

	PhotoURL string `json:"PhotoURL"`
}

type File struct {
	ID string `json:"ID"`

	CTime string `json:"CTime"`

	Name string `json:"Name"`

	Path string `json:"Path"`

	ContentType string `json:"ContentType"`

	FileType string `json:"FileType"`

	Size int `json:"Size"`

	DownloadURL string `json:"DownloadURL"`

	ThumbnailURL string `json:"ThumbnailURL"`

	Author Person `json:"Author"`
}

type Comment struct {
	ID string `json:"ID"`

	CTime string `json:"CTime"`

	MTime string `json:"MTime"`

	Body string `json:"Body"`

	BodyHTML string `json:"BodyHTML"`

	Author Person `json:"Author"`

	Files []File `json:"Files"`
}

type AddCommentResponse struct {
	Comment Comment `json:"Comment"`

	Error string `json:"Error,omitempty"`
}

type RelatedCardsSummary struct {
	Total int `json:"Total"`

	Done int `json:"Done"`

	Progress int `json:"Progress"`
}

type Card struct {
	ID string `json:"ID"`

	CTime string `json:"CTime"`

	MTime string `json:"MTime"`

	Order float64 `json:"Order"`

	TeamID string `json:"TeamID"`

	Slug string `json:"Slug"`

	Title string `json:"Title"`

	Status string `json:"Status"`

	Author Person `json:"Author"`

	Body string `json:"Body"`

	BodyHTML string `json:"BodyHTML"`

	Tags []string `json:"Tags"`

	TakenByCurrentUser bool `json:"TakenByCurrentUser"`

	TakenByPeople []Person `json:"TakenByPeople"`

	Files []File `json:"Files"`

	RelatedCardsSummary RelatedCardsSummary `json:"RelatedCardsSummary"`
}

type CreateCardRequest struct {
	OrgID string `json:"OrgID"`

	TeamID string `json:"TeamID"`

	Title string `json:"Title"`

	ParentTargetKind string `json:"ParentTargetKind"`

	ParentTargetID string `json:"ParentTargetID"`
}

type CreateCardResponse struct {
	Card Card `json:"Card"`

	Error string `json:"Error,omitempty"`
}

type GetCardRequest struct {
	OrgID string `json:"OrgID"`

	CardID string `json:"CardID"`
}

type GetCardResponse struct {
	Card Card `json:"Card"`

	Error string `json:"Error,omitempty"`
}

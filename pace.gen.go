// Code generated by oto; DO NOT EDIT.

package pace

import (
	"bytes"
	"compress/gzip"
	"context"
	"crypto/hmac"
	"crypto/sha256"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"strings"
	"time"

	"github.com/pkg/errors"
)

// Client is used to access Pace services.
type Client struct {
	// RemoteHost is the URL of the remote server that this Client should
	// access. Default: https://pace.dev
	RemoteHost string
	// HTTPClient is the http.Client to use when making HTTP requests.
	HTTPClient *http.Client
	// Debug writes a line of debug log output.
	Debug func(s string)
	// apiKey is the API key to use when interacting with the server.
	apiKey string
	// secret is the Secret to make the HMAC signature
	secret []byte
}

// New makes a new Client.
func New(apiKey, secret string) *Client {
	c := &Client{
		RemoteHost: "https://pace.dev",
		apiKey:     apiKey,
		secret:     []byte(secret),
		Debug:      func(s string) {},
		HTTPClient: &http.Client{Timeout: 10 * time.Second},
	}
	return c
}

// CardsService allows you to programmatically manage cards in Pace.
type CardsService struct {
	client *Client
}

// NewCardsService makes a new client for accessing CardsService services.
func NewCardsService(client *Client) *CardsService {
	return &CardsService{
		client: client,
	}
}

// CreateCard creates a new Card.
func (s *CardsService) CreateCard(ctx context.Context, r CreateCardRequest) (*CreateCardResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.CreateCard: marshal CreateCardRequest")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.CreateCard: generate signature CreateCardRequest")
	}

	url := s.client.RemoteHost + "/api/CardsService.CreateCard"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.CreateCard: NewRequest")
	}
	req.Header.Set("X-API-KEY", s.client.apiKey)
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.CreateCard")
	}
	defer resp.Body.Close()
	var response struct {
		CreateCardResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "CardsService.CreateCard: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.CreateCard: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("CardsService.CreateCard: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.CreateCardResponse, nil
}

// DeleteCard deletes a card.
func (s *CardsService) DeleteCard(ctx context.Context, r DeleteCardRequest) (*DeleteCardResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.DeleteCard: marshal DeleteCardRequest")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.DeleteCard: generate signature DeleteCardRequest")
	}

	url := s.client.RemoteHost + "/api/CardsService.DeleteCard"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.DeleteCard: NewRequest")
	}
	req.Header.Set("X-API-KEY", s.client.apiKey)
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.DeleteCard")
	}
	defer resp.Body.Close()
	var response struct {
		DeleteCardResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "CardsService.DeleteCard: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.DeleteCard: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("CardsService.DeleteCard: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.DeleteCardResponse, nil
}

// GetCard gets a card.
func (s *CardsService) GetCard(ctx context.Context, r GetCardRequest) (*GetCardResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.GetCard: marshal GetCardRequest")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.GetCard: generate signature GetCardRequest")
	}

	url := s.client.RemoteHost + "/api/CardsService.GetCard"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.GetCard: NewRequest")
	}
	req.Header.Set("X-API-KEY", s.client.apiKey)
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.GetCard")
	}
	defer resp.Body.Close()
	var response struct {
		GetCardResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "CardsService.GetCard: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.GetCard: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("CardsService.GetCard: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.GetCardResponse, nil
}

// PutBackCard removes a user from the list of responsbile users. Undoes TakeCard.
func (s *CardsService) PutBackCard(ctx context.Context, r PutBackCardRequest) (*PutBackCardResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.PutBackCard: marshal PutBackCardRequest")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.PutBackCard: generate signature PutBackCardRequest")
	}

	url := s.client.RemoteHost + "/api/CardsService.PutBackCard"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.PutBackCard: NewRequest")
	}
	req.Header.Set("X-API-KEY", s.client.apiKey)
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.PutBackCard")
	}
	defer resp.Body.Close()
	var response struct {
		PutBackCardResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "CardsService.PutBackCard: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.PutBackCard: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("CardsService.PutBackCard: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.PutBackCardResponse, nil
}

// TakeCard takes responsibility for a card. Can be undone with PutBackCard.
func (s *CardsService) TakeCard(ctx context.Context, r TakeCardRequest) (*TakeCardResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.TakeCard: marshal TakeCardRequest")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.TakeCard: generate signature TakeCardRequest")
	}

	url := s.client.RemoteHost + "/api/CardsService.TakeCard"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.TakeCard: NewRequest")
	}
	req.Header.Set("X-API-KEY", s.client.apiKey)
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.TakeCard")
	}
	defer resp.Body.Close()
	var response struct {
		TakeCardResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "CardsService.TakeCard: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.TakeCard: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("CardsService.TakeCard: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.TakeCardResponse, nil
}

// UpdateCard updates the title and body of the card.
func (s *CardsService) UpdateCard(ctx context.Context, r UpdateCardRequest) (*UpdateCardResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.UpdateCard: marshal UpdateCardRequest")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.UpdateCard: generate signature UpdateCardRequest")
	}

	url := s.client.RemoteHost + "/api/CardsService.UpdateCard"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.UpdateCard: NewRequest")
	}
	req.Header.Set("X-API-KEY", s.client.apiKey)
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.UpdateCard")
	}
	defer resp.Body.Close()
	var response struct {
		UpdateCardResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "CardsService.UpdateCard: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.UpdateCard: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("CardsService.UpdateCard: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.UpdateCardResponse, nil
}

// UpdateCardStatus updates a card&#39;s status.
func (s *CardsService) UpdateCardStatus(ctx context.Context, r UpdateCardStatusRequest) (*UpdateCardStatusResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.UpdateCardStatus: marshal UpdateCardStatusRequest")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.UpdateCardStatus: generate signature UpdateCardStatusRequest")
	}

	url := s.client.RemoteHost + "/api/CardsService.UpdateCardStatus"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.UpdateCardStatus: NewRequest")
	}
	req.Header.Set("X-API-KEY", s.client.apiKey)
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.UpdateCardStatus")
	}
	defer resp.Body.Close()
	var response struct {
		UpdateCardStatusResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "CardsService.UpdateCardStatus: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "CardsService.UpdateCardStatus: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("CardsService.UpdateCardStatus: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.UpdateCardStatusResponse, nil
}

// CommentsService allows you to programmatically manage comments in Pace.
type CommentsService struct {
	client *Client
}

// NewCommentsService makes a new client for accessing CommentsService services.
func NewCommentsService(client *Client) *CommentsService {
	return &CommentsService{
		client: client,
	}
}

// AddComment adds a comment.
func (s *CommentsService) AddComment(ctx context.Context, r AddCommentRequest) (*AddCommentResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "CommentsService.AddComment: marshal AddCommentRequest")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "CommentsService.AddComment: generate signature AddCommentRequest")
	}

	url := s.client.RemoteHost + "/api/CommentsService.AddComment"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "CommentsService.AddComment: NewRequest")
	}
	req.Header.Set("X-API-KEY", s.client.apiKey)
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "CommentsService.AddComment")
	}
	defer resp.Body.Close()
	var response struct {
		AddCommentResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "CommentsService.AddComment: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "CommentsService.AddComment: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("CommentsService.AddComment: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.AddCommentResponse, nil
}

// DeleteComment deletes a Comment.
func (s *CommentsService) DeleteComment(ctx context.Context, r DeleteCommentRequest) (*DeleteCommentResponse, error) {
	requestBodyBytes, err := json.Marshal(r)
	if err != nil {
		return nil, errors.Wrap(err, "CommentsService.DeleteComment: marshal DeleteCommentRequest")
	}
	signature, err := generateSignature(requestBodyBytes, s.client.secret)
	if err != nil {
		return nil, errors.Wrap(err, "CommentsService.DeleteComment: generate signature DeleteCommentRequest")
	}

	url := s.client.RemoteHost + "/api/CommentsService.DeleteComment"
	s.client.Debug(fmt.Sprintf("POST %s", url))
	s.client.Debug(fmt.Sprintf(">> %s", string(requestBodyBytes)))
	req, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(requestBodyBytes))
	if err != nil {
		return nil, errors.Wrap(err, "CommentsService.DeleteComment: NewRequest")
	}
	req.Header.Set("X-API-KEY", s.client.apiKey)
	req.Header.Set("X-API-SIGNATURE", signature)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept-Encoding", "gzip")
	req = req.WithContext(ctx)
	resp, err := s.client.HTTPClient.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "CommentsService.DeleteComment")
	}
	defer resp.Body.Close()
	var response struct {
		DeleteCommentResponse
		Error string
	}
	var bodyReader io.Reader = resp.Body
	if strings.Contains(resp.Header.Get("Content-Encoding"), "gzip") {
		decodedBody, err := gzip.NewReader(resp.Body)
		if err != nil {
			return nil, errors.Wrap(err, "CommentsService.DeleteComment: new gzip reader")
		}
		defer decodedBody.Close()
		bodyReader = decodedBody
	}
	respBodyBytes, err := ioutil.ReadAll(bodyReader)
	if err != nil {
		return nil, errors.Wrap(err, "CommentsService.DeleteComment: read response body")
	}
	if err := json.Unmarshal(respBodyBytes, &response); err != nil {
		if resp.StatusCode != http.StatusOK {
			return nil, errors.Errorf("CommentsService.DeleteComment: (%d) %v", resp.StatusCode, string(respBodyBytes))
		}
		return nil, err
	}
	if response.Error != "" {
		return nil, errors.New(response.Error)
	}
	return &response.DeleteCommentResponse, nil
}

// AddCommentRequest is the input object for AddComment.
type AddCommentRequest struct {

	// OrgID is the ID of the org.
	OrgID string `json:"orgID"`

	// TargetKind is the kind of item this comment is for. Can be &#34;card&#34;, &#34;message&#34;, or
	// &#34;showcase&#34;.
	TargetKind string `json:"targetKind"`

	// TargetID is the ID of the target.
	TargetID string `json:"targetID"`

	// Body is the markdown body of the comment.
	Body string `json:"body"`
}

// Person is a human who uses Pace.
type Person struct {

	// ID is the ID of the Person.
	ID string `json:"id"`

	// Username is the Person&#39;s username within the org.
	Username string `json:"username"`

	// Name is the name of the Person.
	Name string `json:"name"`

	// PhotoURL is the URL of a picture of this Person.
	PhotoURL string `json:"photoURL"`
}

// Comment is a single comment in Pace.
type Comment struct {

	// ID is the ID of the comment.
	ID string `json:"id"`

	// CTime is the time this was created.
	CTime string `json:"cTime"`

	// MTime is the time this comment was last modified.
	MTime string `json:"mTime"`

	// Body is the markdown body of the comment.
	Body string `json:"body"`

	// BodyHTML is the HTML formatted body of the comment.
	BodyHTML string `json:"bodyHTML"`

	// Author is the person who posted this comment.
	Author Person `json:"author"`
}

// AddCommentResponse is the output object for AddComment.
type AddCommentResponse struct {

	// Comment is the comment that was created.
	Comment Comment `json:"comment"`
}

// File represents an attached file.
type File struct {

	// ID is the identifier for this file.
	ID string `json:"id"`

	// CTime is the time the file was uploaded.
	CTime string `json:"cTime"`

	// Name is the name of the file.
	Name string `json:"name"`

	// Path is the path of the file.
	Path string `json:"path"`

	// ContentType is the type of the file.
	ContentType string `json:"contentType"`

	// FileType is the type of file. Can be &#34;file&#34;, &#34;video&#34;, &#34;image&#34;, &#34;audio&#34; or
	// &#34;screenshare&#34;.
	FileType string `json:"fileType"`

	// Size is the size of the file in bytes.
	Size int `json:"size"`

	// DownloadURL URL which can be used to get the file.
	DownloadURL string `json:"downloadURL"`

	// ThumbnailURL is an optional thumbnail URL for this file.
	ThumbnailURL string `json:"thumbnailURL"`

	// Author is the person who uploaded the file.
	Author Person `json:"author"`
}

// Card is a card in Pace.
type Card struct {

	// ID is the unique ID of the card within the org.
	ID string `json:"id"`

	// CTime is the time this was created.
	CTime string `json:"cTime"`

	// MTime is the time this comment was last modified.
	MTime string `json:"mTime"`

	// TeamID is the ID of the team that this card belongs to.
	TeamID string `json:"teamID"`

	// Slug is the URL slug for this card.
	Slug string `json:"slug"`

	// Title is the title of the card.
	Title string `json:"title"`

	// Status is the current status of the card.
	Status string `json:"status"`

	// Author is the Person who created this card.
	Author Person `json:"author"`

	// Body is the markdown body of this card.
	Body string `json:"body"`

	// BodyHTML is the HTML rendering of the body of this card.
	BodyHTML string `json:"bodyHTML"`

	// Tags is a list of tags associated with this card.
	Tags []string `json:"tags"`

	// TakenByCurrentUser indicates whether the current user has taken this card or
	// not.
	TakenByCurrentUser bool `json:"takenByCurrentUser"`

	// TakenByPeople is a list of people who have taken responsibility for this Card.
	TakenByPeople []Person `json:"takenByPeople"`

	// Files are the list of files that are attached to this Card.
	Files []File `json:"files"`
}

// CreateCardRequest is the input object for CreateCard.
type CreateCardRequest struct {

	// OrgID is the org ID in which to create the card.
	OrgID string `json:"orgID"`

	// TeamID is the team ID in which to create the card.
	TeamID string `json:"teamID"`

	// Title is the title of the card.
	Title string `json:"title"`

	// ParentTargetKind is the kind of target to relate this card to (e.g. &#34;card&#34;,
	// &#34;message&#34;, or &#34;showcase&#34;)
	ParentTargetKind string `json:"parentTargetKind"`

	// ParentTargetID is the ID of the item to relate this new card to.
	ParentTargetID string `json:"parentTargetID"`
}

// CreateCardResponse is the output object for CreateCard.
type CreateCardResponse struct {

	// Card is the card that was just created.
	Card Card `json:"card"`
}

// DeleteCardRequest is the input object for DeleteCard.
type DeleteCardRequest struct {

	// OrgID is the ID of your org.
	OrgID string `json:"orgID"`

	// CardID is the ID of the card to delete.
	CardID string `json:"cardID"`
}

// DeleteCardResponse is the output object for DeleteCard.
type DeleteCardResponse struct {
}

// GetCardRequest is the input object for GetCard.
type GetCardRequest struct {

	// OrgID is the ID of the org.
	OrgID string `json:"orgID"`

	// CardID is the ID of the card to get.
	CardID string `json:"cardID"`
}

// GetCardResponse is the output object for GetCard.
type GetCardResponse struct {

	// Card is the card.
	Card Card `json:"card"`
}

// PutBackCardRequest is the input object for PutBackCard.
type PutBackCardRequest struct {

	// OrgID is the ID of your org.
	OrgID string `json:"orgID"`

	// CardID is the ID of the card to unassign yourself from.
	CardID string `json:"cardID"`
}

// PutBackCardResponse is the output object for PutBackCard.
type PutBackCardResponse struct {

	// Card is the newly updated Card.
	Card Card `json:"card"`
}

// TakeCardRequest is the input object for TakeCard.
type TakeCardRequest struct {

	// OrgID is the ID of your org.
	OrgID string `json:"orgID"`

	// CardID is the ID of the card to assign yourself to.
	CardID string `json:"cardID"`
}

// TakeCardResponse is the output object for TakeCard.
type TakeCardResponse struct {

	// Card is the newly updated Card.
	Card Card `json:"card"`
}

// UpdateCardRequest is the input object for UpdateCard.
type UpdateCardRequest struct {

	// OrgID is the ID of the org.
	OrgID string `json:"orgID"`

	// CardID is the ID of the card to update.
	CardID string `json:"cardID"`

	// Title is the new title for the card.
	Title string `json:"title"`

	// Body is the new markdown body for the card.
	Body string `json:"body"`
}

// UpdateCardResponse is the output object for UpdateCard.
type UpdateCardResponse struct {

	// Card is the recently updated Card.
	Card Card `json:"card"`
}

// UpdateCardStatusRequest is the input object UpdateCardStatus.
type UpdateCardStatusRequest struct {

	// OrgID is the ID of the org.
	OrgID string `json:"orgID"`

	// CardID is the ID number of the card.
	CardID string `json:"cardID"`

	// Status is the new status of the card. Valid strings are &#34;future&#34;, &#34;next&#34;,
	// &#34;progress&#34;, &#34;done&#34;.
	Status string `json:"status"`
}

// UpdateCardStatusResponse is the output object for UpdateCardService.
type UpdateCardStatusResponse struct {

	// Card is the card that was updated.
	Card Card `json:"card"`
}

// DeleteCommentRequest is the input object for DeleteComment.
type DeleteCommentRequest struct {

	// ID is the ID of the comment to delete.
	ID string `json:"id"`

	// OrgID is the ID of your org.
	OrgID string `json:"orgID"`

	// TargetKind is the kind of target this Comment was made on. Can be &#34;card&#34;,
	// &#34;message&#34;, or &#34;showcase&#34;. Used to help identify the Comment.
	TargetKind string `json:"targetKind"`

	// TargetID is the ID of the target. Used to help identify the Comment.
	TargetID string `json:"targetID"`
}

// DeleteCommentResponse is the output object for DeleteComment.
type DeleteCommentResponse struct {
}

func generateSignature(message, secret []byte) (string, error) {
	mac := hmac.New(sha256.New, secret)
	if _, err := mac.Write(message); err != nil {
		return "", err
	}
	sig := base64.StdEncoding.EncodeToString(mac.Sum(nil))
	return sig, nil
}
